#!/bin/bash

START_TIME=$(date +%s)

log() {
    echo "[$(date '+%H:%M:%S')] [$1] ${@:2}"
}

# Check if jq is installed (required for JSON processing)
check_jq() {
    if ! command -v jq &> /dev/null; then
        log ERROR "jq is not installed - required for JSON processing"
        echo ""
        echo "To install jq:"
        echo "  macOS:   brew install jq"
        echo "  Linux:   apt-get install jq  (Debian/Ubuntu)"
        echo "           yum install jq      (RedHat/CentOS)"
        echo ""
        exit 1
    fi
}

# Validate JSON file
validate_json() {
    local file_path="$1"
    local file_name=$(basename "$file_path")

    if [ ! -f "$file_path" ]; then
        log ERROR "File not found: $file_path"
        return 1
    fi

    if jq empty "$file_path" 2>/dev/null; then
        log INFO "✅ JSON valid: $file_name"
        return 0
    else
        log ERROR "❌ JSON invalid: $file_name"
        echo ""
        echo "JSON validation error in: $file_path"
        echo "Please check the file manually."
        echo "Error details:"
        jq empty "$file_path" 2>&1 | head -5
        echo ""
        return 1
    fi
}

# Function to add footer to audit files
add_audit_footer() {
    local file_path="$1"
    if [ -f "$file_path" ]; then
        echo "" >> "$file_path"
        echo "" >> "$file_path"
        echo "============================================" >> "$file_path"
        echo "Generated by Drupal Audit Tool" >> "$file_path"
        echo "Made with ❤️  by Droptica" >> "$file_path"
        echo "https://www.droptica.com" >> "$file_path"
        echo "Report generated: $(date '+%Y-%m-%d %H:%M:%S')" >> "$file_path"
        echo "============================================" >> "$file_path"
    fi
}

# Function to wrap output in JSON structure with section key
wrap_in_json() {
    local section_name="$1"
    local input_file="$2"
    local temp_file="${input_file}.tmp"

    # Create wrapper JSON structure
    echo "{" > "$temp_file"
    echo "  \"${section_name}\": " >> "$temp_file"

    # Append the original JSON content (entire file as-is)
    if [ -f "$input_file" ]; then
        cat "$input_file" >> "$temp_file"
    fi

    echo "," >> "$temp_file"
    echo "  \"_metadata\": {" >> "$temp_file"
    echo "    \"generated_by\": \"Drupal Audit Tool by Droptica\"," >> "$temp_file"
    echo "    \"about_droptica\": \"Droptica - Drupal development agency specializing in enterprise sites, audits, and Drupal 8-11 migrations.\"," >> "$temp_file"
    echo "    \"website\": \"https://www.droptica.com\"," >> "$temp_file"
    echo "    \"report_generated\": \"$(date '+%Y-%m-%d %H:%M:%S')\"," >> "$temp_file"
    echo "    \"section\": \"${section_name}\"" >> "$temp_file"
    echo "  }" >> "$temp_file"
    echo "}" >> "$temp_file"

    # Replace original file with wrapped version
    mv "$temp_file" "$input_file"
}

# Check for jq before starting
check_jq

# Check if lighthouse is installed (optional - warn if not available)
check_lighthouse() {
    if ! command -v lighthouse &> /dev/null; then
        log WARN "Lighthouse CLI is not installed - performance analysis will be skipped"
        echo ""
        echo "To enable performance analysis, install Lighthouse:"
        echo "  npm install -g lighthouse"
        echo ""
        echo "Continuing without performance analysis..."
        echo ""
        sleep 2
    else
        log INFO "Lighthouse CLI detected - performance analysis enabled"
    fi
}

# Check if pa11y is installed (optional - warn if not available)
check_pa11y() {
    if ! command -v pa11y &> /dev/null; then
        log WARN "Pa11y CLI is not installed - accessibility analysis will be skipped"
        echo ""
        echo "To enable accessibility analysis, install Pa11y:"
        echo "  npm install -g pa11y"
        echo ""
        echo "Continuing without accessibility analysis..."
        echo ""
        sleep 2
    else
        log INFO "Pa11y CLI detected - accessibility analysis enabled"
    fi
}

check_lighthouse
check_pa11y

if [ -z "$1" ] || [ -z "$2" ]; then
    log ERROR "Missing required parameters"
    log INFO "Usage: ./audit.sh <site_name> <production_url> [section_name]"
    log INFO "Example: ./audit.sh mysite.com https://mysite.com"
    log INFO "Example (single section): ./audit.sh mysite.com https://mysite.com system_information"
    log INFO ""
    log INFO "Parameters:"
    log INFO "  site_name      - Directory name in drupal_sites/"
    log INFO "  production_url - Production URL for performance/accessibility tests"
    log INFO "  section_name   - Optional: run only specific section"
    exit 1
fi

SITE_NAME="$1"
PRODUCTION_URL="$2"
SINGLE_SECTION="$3"
SITE_PATH="$(pwd)/drupal_sites/${SITE_NAME}"

# Validate production URL format
if [[ ! "$PRODUCTION_URL" =~ ^(http|https|file)://.*$ ]]; then
    log ERROR "Invalid production URL format"
    log INFO "Production URL must start with http://, https://, or file://"
    log INFO "Examples:"
    log INFO "  - https://example.com"
    log INFO "  - http://example.com"
    log INFO "  - file:///path/to/local/file"
    log INFO ""
    log INFO "Usage: ./audit.sh <site_name> <production_url> [section_name]"
    exit 1
fi

# Display intro banner
echo ""
echo " ____  ____  _   _ ____   ____    _    _   _ "
echo "|  _ \|  _ \| | | / ___| / ___|  / \  | \ | |"
echo "| | | | |_) | | | \___ \| |     / _ \ |  \| |"
echo "| |_| |  _ <| |_| |___) | |___ / ___ \| |\  |"
echo "|____/|_| \_\\___/|____/ \____/_/   \_\_| \_|"
echo ""
echo "Drupal Site Audit Tool"
echo "Made with ❤️  by Droptica"
echo "https://www.droptica.com"
echo ""
echo "======================================"
echo ""

if [ ! -d "$SITE_PATH" ]; then
    log ERROR "Site directory not found: $SITE_PATH"
    exit 1
fi

TIMESTAMP=$(date '+%Y-%m-%d_%H-%M-%S')
BASE_DIR="$(pwd)"
OUTPUT_DIR="${BASE_DIR}/audits_reports/${TIMESTAMP}_${SITE_NAME}"
COMMANDS_DIR="${BASE_DIR}/commands"
OUTPUT_SUBDIR="json"  # Subdirectory name for audit output files (txt or json)
OUTPUT_EXT="json"     # File extension for audit output files (txt or json)

log INFO "Creating output directory: $OUTPUT_DIR"
mkdir -p "$OUTPUT_DIR" || {
    log ERROR "Failed to create output directory"
    exit 1
}

log INFO "Creating ${OUTPUT_SUBDIR} subdirectory"
mkdir -p "$OUTPUT_DIR/${OUTPUT_SUBDIR}" || {
    log ERROR "Failed to create ${OUTPUT_SUBDIR} subdirectory"
    exit 1
}

log INFO "Copying audit template folder"
TEMPLATE_DIR="${BASE_DIR}/template/drupal_audit_template"
TEMPLATE_OUTPUT_DIR="${OUTPUT_DIR}/html"
if [ -d "$TEMPLATE_DIR" ]; then
    cp -r "$TEMPLATE_DIR" "$TEMPLATE_OUTPUT_DIR" || {
        log ERROR "Failed to copy audit template folder"
        exit 1
    }
    log INFO "Audit template folder copied to: ${TEMPLATE_OUTPUT_DIR}/"
else
    log ERROR "Template directory not found: $TEMPLATE_DIR"
    exit 1
fi

log INFO "Changing to site directory: $SITE_PATH"
cd "$SITE_PATH" || {
    log ERROR "Failed to change directory to $SITE_PATH"
    exit 1
}

# Check if DDEV is accessible (project may be running under different path)
log INFO "Checking DDEV availability"
if ddev describe >/dev/null 2>&1 || ddev exec pwd >/dev/null 2>&1; then
    log INFO "DDEV is accessible"
else
    log INFO "DDEV not running, attempting to start..."
    if ddev start >/dev/null 2>&1; then
        log INFO "DDEV started successfully"
    else
        log WARN "Could not start DDEV automatically"
        log WARN "Project may be registered under different path or already running"
        log INFO "Continuing with audit (commands may fail if DDEV is not accessible)"
    fi
fi

# Get basic audit metadata
log INFO "Collecting audit metadata"
AUDIT_DATE=$(date '+%Y-%m-%d')
AUDIT_SITE_NAME="${SITE_NAME}"

# Try to get Drupal version from DDEV
DRUPAL_VERSION=$(ddev drush status --fields=drupal-version --format=string 2>/dev/null || echo "Unknown")

# Get system username as auditor (can be overridden with AUDITOR env var)
AUDIT_BY="${AUDITOR:-$(whoami)}"

log INFO "Updating sidebar metadata in index.html"
INDEX_HTML="${TEMPLATE_OUTPUT_DIR}/index.html"
if [ -f "$INDEX_HTML" ]; then
    # Replace placeholders in sidebar
    sed -i.bak "s/\[Site Name\]/${AUDIT_SITE_NAME}/g" "$INDEX_HTML"
    sed -i.bak "s/\[Drupal Version\]/${DRUPAL_VERSION}/g" "$INDEX_HTML"
    sed -i.bak "s/\[Date\]/${AUDIT_DATE}/g" "$INDEX_HTML"
    sed -i.bak "s/\[Auditor Name\]/${AUDIT_BY}/g" "$INDEX_HTML"
    rm -f "${INDEX_HTML}.bak"
    log INFO "Sidebar metadata updated successfully"
else
    log WARN "index.html not found: $INDEX_HTML"
fi

# Detect document root using helper script
log INFO "Detecting document root"
DETECT_DOCROOT_SCRIPT="${BASE_DIR}/scripts/detect_docroot.sh"
if [ ! -f "$DETECT_DOCROOT_SCRIPT" ]; then
    log ERROR "detect_docroot.sh not found: $DETECT_DOCROOT_SCRIPT"
    exit 1
fi

# Source the detect_docroot script to get DOCROOT variable
source "$DETECT_DOCROOT_SCRIPT"
if [ -z "$DOCROOT" ]; then
    log ERROR "Failed to detect document root"
    exit 1
fi

log INFO "Document root detected: $DOCROOT"
export DOCROOT

# Export production URL for performance and accessibility scripts
log INFO "Production URL set: $PRODUCTION_URL"
export BASE_URL="$PRODUCTION_URL"

# Load commands registry
COMMANDS_REGISTRY="${BASE_DIR}/commands_registry.sh"
if [ ! -f "$COMMANDS_REGISTRY" ]; then
    log ERROR "Commands registry not found: $COMMANDS_REGISTRY"
    exit 1
fi

log INFO "Loading commands registry"
source "$COMMANDS_REGISTRY"

if [ -n "$SINGLE_SECTION" ]; then
    log INFO "Running single section mode: $SINGLE_SECTION"
else
    log INFO "Processing all sections"
fi

EXECUTED_COUNT=0
EXECUTED_SECTIONS=()

# Get unique sections from COMMANDS array (without associative arrays)
SECTIONS_LIST=""
for cmd_line in "${COMMANDS[@]}"; do
    IFS='|' read -r section key type command <<< "$cmd_line"
    if [ -n "$section" ]; then
        # Skip if single section mode and this is not the requested section
        if [ -n "$SINGLE_SECTION" ] && [ "$section" != "$SINGLE_SECTION" ]; then
            continue
        fi
        # Add section if not already in list
        if ! echo "$SECTIONS_LIST" | grep -q "^${section}$"; then
            SECTIONS_LIST="${SECTIONS_LIST}${section}"$'\n'
        fi
    fi
done

# Process each section
for section in $(echo "$SECTIONS_LIST" | grep -v '^$'); do
    log INFO "Processing section: $section"

    output_name="${section}.${OUTPUT_EXT}"
    output_path="${OUTPUT_DIR}/${OUTPUT_SUBDIR}/${output_name}"

    # Initialize JSON output with empty object
    echo "{}" > "$output_path"

    # Process commands for this section
    for cmd_line in "${COMMANDS[@]}"; do
        IFS='|' read -r cmd_section cmd_key cmd_type cmd_command <<< "$cmd_line"

        # Skip if not our section
        if [ "$cmd_section" != "$section" ]; then
            continue
        fi

        log INFO "  → Executing: $cmd_key ($cmd_type)"

        # Execute command in site directory (use eval for proper quote handling)
        cd "$SITE_PATH"
        if [ "$cmd_type" = "json" ]; then
            # For JSON: keep stderr separate (only capture stdout for clean JSON)
            # Redirect stderr to original stderr (fd 2), not to stdout
            result=$(eval "$cmd_command" 2>&2)
        else
            # For text: combine stderr and stdout
            result=$(eval "$cmd_command" 2>&1)
        fi
        cd "$BASE_DIR"

        # Add to JSON output file based on type
        current_json=$(cat "$output_path")
        if [ "$cmd_type" = "json" ]; then
            # Parse as JSON object
            echo "$current_json" | jq --arg key "$cmd_key" --argjson value "$result" '. + {($key): $value}' > "$output_path" 2>/dev/null || {
                log ERROR "Failed to parse JSON for key: $cmd_key"
                echo "$current_json" | jq --arg key "$cmd_key" --arg value "ERROR: Invalid JSON" '. + {($key): $value}' > "$output_path"
            }
        else
            # Treat as text string
            echo "$current_json" | jq --arg key "$cmd_key" --arg value "$result" '. + {($key): $value}' > "$output_path"
        fi
    done

    # Wrap in JSON structure if output format is JSON
    if [ "$OUTPUT_EXT" = "json" ]; then
        wrap_in_json "$section" "$output_path"

        # Validate JSON after wrapping
        if validate_json "$output_path"; then
            log INFO "Completed: $section -> ${OUTPUT_SUBDIR}/$output_name"
            EXECUTED_COUNT=$((EXECUTED_COUNT + 1))
            EXECUTED_SECTIONS+=("$section")

            # Inject JSON into ALL HTML templates that contain the placeholder
            # Read JSON content (extract only the section data, not metadata wrapper)
            json_content=$(jq -c ".${section}" "$output_path" 2>/dev/null)

            if [ $? -eq 0 ] && [ -n "$json_content" ]; then
                # Escape special characters for sed (including pipe)
                json_escaped=$(echo "$json_content" | sed 's/[&/\|]/\\&/g')

                # Convert section name to uppercase for placeholder (e.g., system_information -> SYSTEM_INFORMATION)
                section_upper=$(echo "${section}" | tr '[:lower:]' '[:upper:]')
                placeholder="__${section_upper}_JSON_PLACEHOLDER__"

                # Find all HTML files containing this placeholder
                html_files_with_placeholder=$(grep -l "${placeholder}" "${TEMPLATE_OUTPUT_DIR}/includes/"*.html 2>/dev/null)

                if [ -n "$html_files_with_placeholder" ]; then
                    log INFO "  → Found HTML templates with placeholder ${placeholder}:"
                    while IFS= read -r html_file; do
                        html_filename=$(basename "$html_file")
                        log INFO "     - ${html_filename}"
                        sed -i.bak "s|${placeholder}|${json_escaped}|g" "$html_file"
                        rm -f "${html_file}.bak"
                    done <<< "$html_files_with_placeholder"
                    log INFO "  → JSON injected successfully"
                else
                    log WARN "  → No HTML templates found with placeholder: ${placeholder}"
                fi
            else
                log ERROR "  → Failed to extract JSON content for injection"
            fi
        else
            log ERROR "JSON validation failed for: $section"
        fi
    else
        # Add footer for non-JSON formats
        add_audit_footer "$output_path"
        log INFO "Completed: $section -> ${OUTPUT_SUBDIR}/$output_name"
        EXECUTED_COUNT=$((EXECUTED_COUNT + 1))
        EXECUTED_SECTIONS+=("$section")
    fi
done

END_TIME=$(date +%s)
ELAPSED_TIME=$((END_TIME - START_TIME))
ELAPSED_MINUTES=$((ELAPSED_TIME / 60))
ELAPSED_SECONDS=$((ELAPSED_TIME % 60))

log INFO "All sections processed"
log INFO "Results saved in: $OUTPUT_DIR"

echo ""
echo "======================================"
echo "EXECUTION SUMMARY"
echo "======================================"
echo "Total execution time: ${ELAPSED_MINUTES}m ${ELAPSED_SECONDS}s"
echo "Sections executed: ${EXECUTED_COUNT}"
echo ""
echo "Executed sections:"
for section in "${EXECUTED_SECTIONS[@]}"; do
    echo "  - $section"
done
echo ""
echo "Report location:"
echo "  - HTML: ${OUTPUT_DIR}/html/index.html"
echo "  - JSON: ${OUTPUT_DIR}/json/"
echo "======================================"
